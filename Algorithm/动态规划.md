---
title: 动态规划
date: 2018-01-22 13:13:00
mathjax: false
tags: algorithm
---
动态规划算法，将给定的复杂问题分割为子问题，并把这些子问题的解保存在一个表中供程序查找，以避免重复计算。

一般，具有以下两种属性的问题可以通过动态规划算法求解：1）重叠子问题，2）最优子结构。
<!--more-->
## 重叠子问题
像分治法一样，动态规划算法结合子问题的解得到原问题的解。当相同子问题的解需要被多次使用的时候，我们应该使用动态规划，将这些子问题的解保存在一个表中，再次求解的时候直接查表就可以，不需要再重复计算。当不存在重叠子问题的时候，动态规划算法是没有必要使用的。

以斐波那契数求解为例，

```
/* simple recursive program for Fibonacci numbers */
int fib(int n)
{
   if ( n <= 1 )
      return n;
   return fib(n-1) + fib(n-2);
}
```
求解fib(5)的递归树中存在大量的重复计算。
```
                         fib(5)
                     /             \
               fib(4)                fib(3)
             /      \                /     \
         fib(3)      fib(2)         fib(2)    fib(1)
        /     \        /    \       /    \
  fib(2)   fib(1)  fib(1) fib(0) fib(1) fib(0)
  /    \
fib(1) fib(0)
```
可以看到，fib(3)被调用了两次，fib(2)被调用了三次。将这些解用一个表存下来，就可以省去递归的多次重复计算。

递归程序有两种编写方法，a）Memoization（自顶向下）b）Tabulation（由下往上）
### a) Memoization
预先分配好内存的程序是在递归调用程序的基础上做了一点点修改，在**计算之前先查找**，当需要一个子问题的解时，先在查找表中查找，如果子问题的解已经计算好了则直接返回该解，否则计算该子问题的解并把结构存入查找表。
```
/* C/C++ program for Memoized version for nth Fibonacci number */
#include<stdio.h>
#define NIL -1
#define MAX 100
 
int lookup[MAX];
 
/* Function to initialize NIL values in lookup table */
void _initialize()
{
  int i;
  for (i = 0; i < MAX; i++)
    lookup[i] = NIL;
}
 
/* function for nth Fibonacci number */
int fib(int n)
{
   if (lookup[n] == NIL)
   {
      if (n <= 1)
         lookup[n] = n;
      else
         lookup[n] = fib(n-1) + fib(n-2);
   }
 
   return lookup[n];
}
 
int main ()
{
  int n = 40;
  _initialize();
  printf("Fibonacci number is %d ", fib(n));
  return 0;
}
```

### b) Tabulation
在这种风格的代码中，程序自底向上构建查找表，并返回查找表中的最新元素。例如，在求解fib(n)的过程中，我们先计算fib(0)，然后是fib(1)，接着是fib(2)，依此继续。最终自底向上构建了子问题的解。
```
/* C program for Tabulated version */
#include<stdio.h>
int fib(int n)
{
  int f[n+1];
  int i;
  f[0] = 0;   f[1] = 1; 
  for (i = 2; i <= n; i++)
      f[i] = f[i-1] + f[i-2];
 
  return f[n];
}
  
int main ()
{
  int n = 9;
  printf("Fibonacci number is %d ", fib(n));
  return 0;
}
```
Tabulated 和 Memoized两种风格的代码都保存了子问题的解。在Memoized的版本中，查找表是按需填充的，而Tabulated版本中的查找表则是自底向上，一个接着一个，最终完全被填充的，Memoized版本中查找表的元素不一定都需要被填充，如[最长公共子序列问题](https://en.wikipedia.org/wiki/Longest_common_subsequence_problem)。

## 最优子结构

## 参考文献: 

- [数据结构与算法分析——C语言描述](https://book.douban.com/subject/1139426/)

- [GeeksforGeeks](https://www.geeksforgeeks.org/fundamentals-of-algorithms/)
