## Day 1

1. 寻找数组中出现次数超过一半的元素->寻找数组中出现次数超过1/3的元素

2. 股票的买入卖出时间，一次买入卖出 -> k次买入卖出

	- 一次买入卖出，[Leetcode121](https://github.com/shouguicai/Notes/blob/master/LeetCode/Leetcode121_Best%20Time%20to%20Buy%20and%20Sell%20Stock.md)

		- 思路1：One Pass，更新最低买入价格的同时更新最大利润。

			```
			int maxProfit(vector<int> prices)
			{

				int minprice = INT_MAX;
				int maxprofit = 0;
				for(int i = 0; i < prices.size();i++)
				{
					if(prices[i] < minprice)
						minprice = prices[i];
					else if(prices[i] - minprice > maxprofit)
						maxprofit = prices[i] - minprice;
				}
				return maxprofit;
			}
			```

		- 思路2：转化为最大连续子数组和问题。
		假设每天都以当天的价格进行卖出买入（第一天只有买入，
		最后一天只有卖出），第k的利润为当天的卖出价减去k-1天
		的买入价。这样问题就转化为了最大连续子数组和问题。

			算法分为两步，

			- 计算原数组相邻元素差
			
				```
				profit[i] = prices[i] - prices[i-1];
				```

			- 求最大连续子数组和（DP）

				```
				dp[i] = profit[i] + max(dp[i-1],0);
				maxprofit = max(maxprofit,dp[i]);
				```

				其中，dp[i]是第i个元素为最后一个元素时的最大连续子数组和。

			两步可以共用一个for循环```dp[i] = prices[i] - prices[i-1] + max(dp[i-1],0);```


	- k次买入卖出，[Leetcode122](https://github.com/shouguicai/Notes/blob/master/LeetCode/Leetcode122_Best%20Time%20to%20Buy%20and%20Sell%20Stock%20II.md)

		类似于一次买入卖出时的思路2，计算相邻两天买入卖出的利润，并累加大于0的profit
		
		```
		maxprofit = max(0,prices[i] - prices[i-1]);
		```

3. 寻找数组中的最长递增子序列，寻找最长长度 -> 输出最长递增子序列

 	- 寻找最长长度，[GeeksforGeeks_LIS](https://github.com/shouguicai/Notes/blob/master/GeeksforGeeks/Longest%20Increasing%20Subsequence.md)，
 	  [Leetcode300](https://github.com/shouguicai/Notes/blob/master/LeetCode/Leetcode300_Longest%20Increasing%20Subsequence.md)

 	  	用L[i]表示以nums[i]结尾的最长递增子序列长度，递推关系为，

 	  	```
 	  	L[i] = 1 + max(L[j]); for all j satisfy L[j] < L[i] 
 	  	```

 	  	若不存在满足条件的j，则```L[i] = 1;```，递归解法存在重复计算，复杂度O(n^3)，应动态规划，复杂度O(n^2)。

 	  	```
 	  	// bottom up
        for(int i = 0; i < n; i++)
        {
            for(int j = 0; j < i; j++)
                if(nums[i] > nums[j] && dp[i] < dp[j] + 1)
                    dp[i] = dp[j] + 1;
            max = max(max,dp[i]);
        }
 	  	```

	- 输出最长递增子序列，[GeeksforGeeks_LIS](https://www.geeksforgeeks.org/construction-of-longest-increasing-subsequence-using-dynamic-programming/)

		定义L[i]为存储以nums[i]结尾的最长递增子序列，L[i]类型为vector，递推关系为，
		
		```
		L[i] = {Max(L[j])} + nums[i]，where j < i and nums[j] < nums[i]
		```
		若不存在满足条件的j，则```L[i] = nums[i];```

		```
 	  	// bottom up
        for(int i = 0; i < n; i++)
        {
            for(int j = 0; j < i; j++)
                if(nums[i] > nums[j] && dp[i].size() < dp[j].size() + 1)
                    dp[i] = dp[j];
            dp[i].push_back(nums[i]);
        }

        for (vector<int> x : dp)
        	if (x.size() > max.size())
            	max = x;

        print(max);
        ```

4. 翻转链表，[Leetcode206](https://github.com/shouguicai/Notes/blob/master/LeetCode/Leetcode206_Reverse%20Linked%20List.md)

	假设从第二个节点到最后的节点已经完成翻转

	```
    ListNode* p = reverseList(head -> next);
    (head -> next) -> next = head;
    head -> next = NULL;
    return p;
	```

5. 画建最小堆的过程
6. 先序遍历二叉树，非递归
7. 链表的第一个公共节点，优化问题，[Leetcode160](https://github.com/shouguicai/Notes/blob/master/LeetCode/Leetcode160_Intersection%20of%20Two%20Linked%20Lists.md)

	- 思路1: Hash表。

		把链表A的ListNode地址存入```unordered_set<ListNode*>```,
	然后遍历链表B，并查询ListNode地址在Hash表中是否存在。

8. 最大连续子数组和，[Leetcode053](https://github.com/shouguicai/Notes/blob/master/LeetCode/Leetcode053_Maximum%20Subarray.md)

	递推关系，

	```
	dp[i] = nums[i] + (dp[i-1]>0? dp[i-1]:0);
    maxm = max(maxm,dp[i]);
	```

	引伸：最大积连续子数组,见[Leetcode152](https://github.com/shouguicai/Notes/blob/master/LeetCode/Leetcode152_Maximum%20Product%20Subarray.md),

	- 思路用dp_max[i],dp_min[i]分别记录nums[i:end]中包含nums[i]的最大最小积，

		```
		for(int i = n -2; i >= 0; i--)
        {   
            if(nums[i] < 0)
            {
                dp_max[i] = max(nums[i],nums[i] * dp_min[i+1]);
                dp_min[i] = min(nums[i],nums[i] * dp_max[i+1]);
            }
            else
            {
                dp_max[i] = max(nums[i],nums[i] * dp_max[i+1]);
                dp_min[i] = min(nums[i],nums[i] * dp_min[i+1]);
            }
            max_product = max(max_product,dp_max[i]);
        }
        return max_product;
		```

		取max和min是因为考虑到 dp_min[i+1] , dp_max[i+1]和nums[i]异号的可能

9. 后缀子串
10. 手写数组旋转、不用额外的空间
