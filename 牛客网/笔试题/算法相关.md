1. 寻找数组中出现次数超过一半的元素->寻找数组中出现次数超过1/3的元素

2. 股票的买入卖出时间，一次买入卖出 -> k次买入卖出

	- 一次买入卖出，[Leetcode121](https://github.com/shouguicai/Notes/blob/master/LeetCode/Leetcode121_Best%20Time%20to%20Buy%20and%20Sell%20Stock.md)

		- 思路1：One Pass，更新最低买入价格的同时更新最大利润。

			```
			int maxProfit(vector<int> prices)
			{

				int minprice = INT_MAX;
				int maxprofit = 0;
				for(int i = 0; i < prices.size();i++)
				{
					if(prices[i] < minprice)
						minprice = prices[i];
					else if(prices[i] - minprice > maxprofit)
						maxprofit = prices[i] - minprice;
				}
				return maxprofit;
			}
			```

		- 思路2：转化为最大连续子数组和问题。
		假设每天都以当天的价格进行卖出买入（第一天只有买入，
		最后一天只有卖出），第k的利润为当天的卖出价减去k-1天
		的买入价。这样问题就转化为了最大连续子数组和问题。

			算法分为两步，

			- 计算原数组相邻元素差
			
				```
				profit[i] = prices[i] - prices[i-1];
				```

			- 求最大连续子数组和（DP）

				```
				dp[i] = profit[i] + max(dp[i-1],0);
				maxprofit = max(maxprofit,dp[i]);
				```

				其中，dp[i]是第i个元素为最后一个元素时的最大连续子数组和。

			两步可以共用一个for循环```dp[i] = prices[i] - prices[i-1] + max(dp[i-1],0);```


	- k次买入卖出，[Leetcode122](https://github.com/shouguicai/Notes/blob/master/LeetCode/Leetcode122_Best%20Time%20to%20Buy%20and%20Sell%20Stock%20II.md)

		类似于一次买入卖出时的思路2，计算相邻两天买入卖出的利润，并累加大于0的profit
		
		```
		maxprofit = max(0,prices[i] - prices[i-1]);
		```

3. 寻找数组中的最长递增子序列，寻找最长长度 -> 输出最长递增子序列

 	- 寻找最长长度
	
		见[GeeksforGeeks_LIS](https://github.com/shouguicai/Notes/blob/master/GeeksforGeeks/Longest%20Increasing%20Subsequence.md)和[Leetcode300](https://github.com/shouguicai/Notes/blob/master/LeetCode/Leetcode300_Longest%20Increasing%20Subsequence.md)

	- 输出最长递增子序列
	
		见[GeeksforGeeks_LIS](https://www.geeksforgeeks.org/construction-of-longest-increasing-subsequence-using-dynamic-programming/)

4. 翻转链表

	见[Leetcode206](https://github.com/shouguicai/Notes/blob/master/LeetCode/Leetcode206_Reverse%20Linked%20List.md)

5. 画建最小堆的过程
6. 先序遍历二叉树，非递归
7. 链表的第一个公共节点，优化问题

	见[Leetcode160](https://github.com/shouguicai/Notes/blob/master/LeetCode/Leetcode160_Intersection%20of%20Two%20Linked%20Lists.md)

8. 最大连续子数组和

	见[Leetcode053](https://github.com/shouguicai/Notes/blob/master/LeetCode/Leetcode053_Maximum%20Subarray.md)

	引申最大积连续子数组,见[Leetcode152](https://github.com/shouguicai/Notes/blob/master/LeetCode/Leetcode152_Maximum%20Product%20Subarray.md)

9. 后缀子串
10. 手写数组旋转、不用额外的空间
